//
// Generated file, do not edit! Created by nedtool 5.5 from core4inet/linklayer/ethernet/avb/SRPFrame.msg.
//

#ifndef __CORE4INET_SRPFRAME_M_H
#define __CORE4INET_SRPFRAME_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0505
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
//INET
#include "inet/linklayer/common/MACAddress.h"

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Winconsistent-missing-override"
#elif defined(__GNUC__) && __GNUC__ >= 5
#  pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
// }}


namespace CoRE4INET {

/**
 * Class generated from <tt>core4inet/linklayer/ethernet/avb/SRPFrame.msg:38</tt> by nedtool.
 * <pre>
 * //
 * // Represents a Stream Reservation Protokol Frame (SRP)
 * //
 * // \@see ~EtherFrame
 * //
 * // \@author Philipp Meyer
 * //
 * packet SRPFrame
 * {
 *     // ID of the AVB Stream
 *     // 64 Bit Field (48bit MAC + 16bit UniqueID)
 *     uint64_t streamID;
 * 
 *     // for internal implementation:
 *     string displayString = "b=15,15,rect,black,black,5";
 * }
 * </pre>
 */
class SRPFrame : public ::omnetpp::cPacket
{
  protected:
    uint64_t streamID;
    ::omnetpp::opp_string displayString;

  private:
    void copy(const SRPFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SRPFrame&);

  public:
    SRPFrame(const char *name=nullptr, short kind=0);
    SRPFrame(const SRPFrame& other);
    virtual ~SRPFrame();
    SRPFrame& operator=(const SRPFrame& other);
    virtual SRPFrame *dup() const override {return new SRPFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint64_t getStreamID() const;
    virtual void setStreamID(uint64_t streamID);
    virtual const char * getDisplayString() const;
    virtual void setDisplayString(const char * displayString);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SRPFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SRPFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>core4inet/linklayer/ethernet/avb/SRPFrame.msg:47</tt> by nedtool.
 * <pre>
 * packet TalkerAdvertise extends SRPFrame
 * {
 *     byteLength = 25;
 * 
 *     // DataFrameParameters => destination adress and vlan identifier
 *     // 64 Bit Field
 *     inet::MACAddress destination_address; //only one Talker allowed per destination_address
 *     uint16_t vlan_identifier;
 *     // TSpec => Max frame size and sending interval of an AVB stream
 *     // 32 Bit Field
 *     uint16_t MaxFrameSize;
 *     uint16_t MaxIntervalFrames;
 *     // PriorityAndRank => Data Frame Priority: 6 = SRClass A & 5 = SRClass B
 *     // 8 Bit Field (3 Bit Data Frame Priority | 1 Bit Rank | 4 Bit Reserved (Zero filled))
 *     uint8_t priorityAndRank;
 *     // notused
 *     // 32 Bit Field
 *     uint32_t accumulatedLatency;
 * }
 * </pre>
 */
class TalkerAdvertise : public ::CoRE4INET::SRPFrame
{
  protected:
    inet::MACAddress destination_address;
    uint16_t vlan_identifier;
    uint16_t MaxFrameSize;
    uint16_t MaxIntervalFrames;
    uint8_t priorityAndRank;
    uint32_t accumulatedLatency;
    inet::MACAddress source_address; //emergency solution, todo: remove

  private:
    void copy(const TalkerAdvertise& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TalkerAdvertise&);

  public:
    TalkerAdvertise(const char *name=nullptr, short kind=0);
    TalkerAdvertise(const TalkerAdvertise& other);
    virtual ~TalkerAdvertise();
    TalkerAdvertise& operator=(const TalkerAdvertise& other);
    virtual TalkerAdvertise *dup() const override {return new TalkerAdvertise(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::MACAddress& getDestination_address();
    virtual const inet::MACAddress& getDestination_address() const {return const_cast<TalkerAdvertise*>(this)->getDestination_address();}
    virtual void setDestination_address(const inet::MACAddress& destination_address);
    virtual uint16_t getVlan_identifier() const;
    virtual void setVlan_identifier(uint16_t vlan_identifier);
    virtual uint16_t getMaxFrameSize() const;
    virtual void setMaxFrameSize(uint16_t MaxFrameSize);
    virtual uint16_t getMaxIntervalFrames() const;
    virtual void setMaxIntervalFrames(uint16_t MaxIntervalFrames);
    virtual uint8_t getPriorityAndRank() const;
    virtual void setPriorityAndRank(uint8_t priorityAndRank);
    virtual uint32_t getAccumulatedLatency() const;
    virtual void setAccumulatedLatency(uint32_t accumulatedLatency);

    virtual inet::MACAddress& getSource_address();
    virtual void setSource_address(const inet::MACAddress& source_address);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TalkerAdvertise& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TalkerAdvertise& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>core4inet/linklayer/ethernet/avb/SRPFrame.msg:66</tt> by nedtool.
 * <pre>
 * packet TalkerFailed extends TalkerAdvertise
 * {
 *     byteLength = 34;
 *     // FailureInformation
 * 	//
 * 	// 72 Bit Field
 * }
 * </pre>
 */
class TalkerFailed : public ::CoRE4INET::TalkerAdvertise
{
  protected:

  private:
    void copy(const TalkerFailed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TalkerFailed&);

  public:
    TalkerFailed(const char *name=nullptr, short kind=0);
    TalkerFailed(const TalkerFailed& other);
    virtual ~TalkerFailed();
    TalkerFailed& operator=(const TalkerFailed& other);
    virtual TalkerFailed *dup() const override {return new TalkerFailed(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TalkerFailed& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TalkerFailed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>core4inet/linklayer/ethernet/avb/SRPFrame.msg:73</tt> by nedtool.
 * <pre>
 * packet ListenerReady extends SRPFrame
 * {
 *     byteLength = 8;
 *     uint16_t vlan_identifier;
 * }
 * </pre>
 */
class ListenerReady : public ::CoRE4INET::SRPFrame
{
  protected:
    uint16_t vlan_identifier;

  private:
    void copy(const ListenerReady& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ListenerReady&);

  public:
    ListenerReady(const char *name=nullptr, short kind=0);
    ListenerReady(const ListenerReady& other);
    virtual ~ListenerReady();
    ListenerReady& operator=(const ListenerReady& other);
    virtual ListenerReady *dup() const override {return new ListenerReady(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getVlan_identifier() const;
    virtual void setVlan_identifier(uint16_t vlan_identifier);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ListenerReady& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ListenerReady& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>core4inet/linklayer/ethernet/avb/SRPFrame.msg:78</tt> by nedtool.
 * <pre>
 * packet ListenerAskingFailed extends SRPFrame
 * {
 *     byteLength = 17;
 *     uint16_t vlan_identifier;
 * 
 *     // FailureInformation
 * 	//
 * 	// 72 Bit Field	
 * }
 * </pre>
 */
class ListenerAskingFailed : public ::CoRE4INET::SRPFrame
{
  protected:
    uint16_t vlan_identifier;

  private:
    void copy(const ListenerAskingFailed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ListenerAskingFailed&);

  public:
    ListenerAskingFailed(const char *name=nullptr, short kind=0);
    ListenerAskingFailed(const ListenerAskingFailed& other);
    virtual ~ListenerAskingFailed();
    ListenerAskingFailed& operator=(const ListenerAskingFailed& other);
    virtual ListenerAskingFailed *dup() const override {return new ListenerAskingFailed(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getVlan_identifier() const;
    virtual void setVlan_identifier(uint16_t vlan_identifier);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ListenerAskingFailed& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ListenerAskingFailed& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>core4inet/linklayer/ethernet/avb/SRPFrame.msg:87</tt> by nedtool.
 * <pre>
 * packet ListenerReadyFailed extends ListenerReady
 * {
 *     byteLength = 17;
 * 
 *     // FailureInformation
 * 	//
 * 	// 72 Bit Field
 * }
 * </pre>
 */
class ListenerReadyFailed : public ::CoRE4INET::ListenerReady
{
  protected:

  private:
    void copy(const ListenerReadyFailed& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ListenerReadyFailed&);

  public:
    ListenerReadyFailed(const char *name=nullptr, short kind=0);
    ListenerReadyFailed(const ListenerReadyFailed& other);
    virtual ~ListenerReadyFailed();
    ListenerReadyFailed& operator=(const ListenerReadyFailed& other);
    virtual ListenerReadyFailed *dup() const override {return new ListenerReadyFailed(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ListenerReadyFailed& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ListenerReadyFailed& obj) {obj.parsimUnpack(b);}

} // namespace CoRE4INET

#endif // ifndef __CORE4INET_SRPFRAME_M_H

