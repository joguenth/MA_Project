//
// Generated file, do not edit! Created by nedtool 5.5 from sdn4core/netconf/messages/NetConfMessage.msg.
//

#ifndef __SDN4CORE_NETCONFMESSAGE_M_H
#define __SDN4CORE_NETCONFMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0505
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif


namespace SDN4CoRE {

/**
 * Enum generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:25</tt> by nedtool.
 * <pre>
 * //
 * // Enum for all NetConf message types
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * enum NetConfMessageType
 * {
 *     NETCONFMESSAGETYPE_RPC = 0;
 *     NETCONFMESSAGETYPE_RPCREPLY = 1;
 * }
 * </pre>
 */
enum NetConfMessageType {
    NETCONFMESSAGETYPE_RPC = 0,
    NETCONFMESSAGETYPE_RPCREPLY = 1
};

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:43</tt> by nedtool.
 * <pre>
 * //
 * // Base class for all NetConf messages.
 * // The Messages layer provides a simple, transport-independent
 * // framing mechanism for encoding RPCs and notifications.
 * //
 * // RPC Model
 * //
 * // The NETCONF protocol uses an RPC-based communication model.  NETCONF
 * // peers use <rpc> and <rpc-reply> elements to provide transport-
 * // protocol-independent framing of NETCONF requests and responses.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfMessage
 * {
 *     int messageType \@enum(NetConfMessageType);
 * }
 * </pre>
 */
class NetConfMessage : public ::omnetpp::cPacket
{
  protected:
    int messageType;

  private:
    void copy(const NetConfMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfMessage&);

  public:
    NetConfMessage(const char *name=nullptr, short kind=0);
    NetConfMessage(const NetConfMessage& other);
    virtual ~NetConfMessage();
    NetConfMessage& operator=(const NetConfMessage& other);
    virtual NetConfMessage *dup() const override {return new NetConfMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getMessageType() const;
    virtual void setMessageType(int messageType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:60</tt> by nedtool.
 * <pre>
 * //
 * // The <rpc> element is used to enclose a NETCONF request sent from the
 * // client to the server.
 * // The <rpc> element has a mandatory attribute "message-id", which is a
 * // string chosen by the sender of the RPC that will commonly encode a
 * // monotonically increasing integer. The receiver of the RPC does not
 * // decode or interpret this string but simply saves it to be used as a
 * // "message-id" attribute in any resulting <rpc-reply> message.
 * //
 * // RPC's usually encapsulate an operation \@see ~NetConfOperation.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfMessage_RPC extends NetConfMessage
 * {
 *     messageType = NetConfMessageType::NETCONFMESSAGETYPE_RPC;
 *     string message_id;//dont forget to add string size to byteLength
 *     byteLength = 25;//<rpc message-id=""></rpc>
 * }
 * </pre>
 */
class NetConfMessage_RPC : public ::SDN4CoRE::NetConfMessage
{
  protected:
    ::omnetpp::opp_string message_id;

  private:
    void copy(const NetConfMessage_RPC& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfMessage_RPC&);

  public:
    NetConfMessage_RPC(const char *name=nullptr, short kind=0);
    NetConfMessage_RPC(const NetConfMessage_RPC& other);
    virtual ~NetConfMessage_RPC();
    NetConfMessage_RPC& operator=(const NetConfMessage_RPC& other);
    virtual NetConfMessage_RPC *dup() const override {return new NetConfMessage_RPC(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getMessage_id() const;
    virtual void setMessage_id(const char * message_id);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfMessage_RPC& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfMessage_RPC& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:71</tt> by nedtool.
 * <pre>
 * //
 * // Base class for all RPC-reply elements, such as data, error or ok
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConf_RPCReplyElement
 * {
 * }
 * </pre>
 */
class NetConf_RPCReplyElement : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const NetConf_RPCReplyElement& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConf_RPCReplyElement&);

  public:
    NetConf_RPCReplyElement(const char *name=nullptr, short kind=0);
    NetConf_RPCReplyElement(const NetConf_RPCReplyElement& other);
    virtual ~NetConf_RPCReplyElement();
    NetConf_RPCReplyElement& operator=(const NetConf_RPCReplyElement& other);
    virtual NetConf_RPCReplyElement *dup() const override {return new NetConf_RPCReplyElement(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConf_RPCReplyElement& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConf_RPCReplyElement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:87</tt> by nedtool.
 * <pre>
 * //
 * // The <rpc-reply> message is sent in response to an <rpc> (\@see ~NetConfMessage_RPC) message.
 * //
 * // The <rpc-reply> element has a mandatory attribute "message-id", which
 * // is equal to the "message-id" attribute of the <rpc> for which this is
 * // a response.
 * //
 * // The response data is encoded as one or more child elements to the
 * // <rpc-reply> element.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfMessage_RPCReply extends NetConfMessage
 * {
 *     messageType = NetConfMessageType::NETCONFMESSAGETYPE_RPCREPLY;
 *     string message_id;//dont forget to add filter size to length
 *     byteLength = 37;//<rpc-reply> message-id=""></rpc-reply>
 * }
 * </pre>
 */
class NetConfMessage_RPCReply : public ::SDN4CoRE::NetConfMessage
{
  protected:
    ::omnetpp::opp_string message_id;

  private:
    void copy(const NetConfMessage_RPCReply& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfMessage_RPCReply&);

  public:
    NetConfMessage_RPCReply(const char *name=nullptr, short kind=0);
    NetConfMessage_RPCReply(const NetConfMessage_RPCReply& other);
    virtual ~NetConfMessage_RPCReply();
    NetConfMessage_RPCReply& operator=(const NetConfMessage_RPCReply& other);
    virtual NetConfMessage_RPCReply *dup() const override {return new NetConfMessage_RPCReply(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getMessage_id() const;
    virtual void setMessage_id(const char * message_id);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfMessage_RPCReply& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfMessage_RPCReply& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:98</tt> by nedtool.
 * <pre>
 * //
 * // Baseclass for any userdata to be incapsulated in a NetConfMessage_RPCReply.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConf_RPCReplyElement_Data extends NetConf_RPCReplyElement
 * {
 * }
 * </pre>
 */
class NetConf_RPCReplyElement_Data : public ::SDN4CoRE::NetConf_RPCReplyElement
{
  protected:

  private:
    void copy(const NetConf_RPCReplyElement_Data& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConf_RPCReplyElement_Data&);

  public:
    NetConf_RPCReplyElement_Data(const char *name=nullptr, short kind=0);
    NetConf_RPCReplyElement_Data(const NetConf_RPCReplyElement_Data& other);
    virtual ~NetConf_RPCReplyElement_Data();
    NetConf_RPCReplyElement_Data& operator=(const NetConf_RPCReplyElement_Data& other);
    virtual NetConf_RPCReplyElement_Data *dup() const override {return new NetConf_RPCReplyElement_Data(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConf_RPCReplyElement_Data& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConf_RPCReplyElement_Data& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:111</tt> by nedtool.
 * <pre>
 * //
 * // error-type:  Defines the conceptual layer that the error occurred.
 * //    Enumeration.  One of:
 * //    *  transport (layer: Secure Transport)
 * //    *  rpc (layer: Messages)
 * //    *  protocol (layer: Operations)
 * //    *  application (layer: Content)
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * enum NetConf_RPCReplyElement_Error_Type
 * {
 *     NETCONF_REPLY_ERROR_TYPE_TRANSPORT = 0;
 *     NETCONF_REPLY_ERROR_TYPE_RPC = 1;
 *     NETCONF_REPLY_ERROR_TYPE_PROTOCOL = 2;
 *     NETCONF_REPLY_ERROR_TYPE_APPLICATION = 3;
 * }
 * </pre>
 */
enum NetConf_RPCReplyElement_Error_Type {
    NETCONF_REPLY_ERROR_TYPE_TRANSPORT = 0,
    NETCONF_REPLY_ERROR_TYPE_RPC = 1,
    NETCONF_REPLY_ERROR_TYPE_PROTOCOL = 2,
    NETCONF_REPLY_ERROR_TYPE_APPLICATION = 3
};

/**
 * Enum generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:126</tt> by nedtool.
 * <pre>
 * //
 * // error-severity:  Contains an enum identifying the error severity, as
 * //    determined by the device.  One of:
 * //    *  error
 * //    *  warning
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * enum NetConf_RPCReplyElement_Error_Severity
 * {
 *     NETCONF_REPLY_ERROR_SEVIRITY_ERROR = 0;
 *     NETCONF_REPLY_ERROR_SEVIRITY_WARNING = 1;
 * }
 * </pre>
 */
enum NetConf_RPCReplyElement_Error_Severity {
    NETCONF_REPLY_ERROR_SEVIRITY_ERROR = 0,
    NETCONF_REPLY_ERROR_SEVIRITY_WARNING = 1
};

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:156</tt> by nedtool.
 * <pre>
 * //
 * // The <rpc-error> element is sent in <rpc-reply> messages if an error
 * // occurs during the processing of an <rpc> request.
 * //
 * // The <rpc-error> element includes the following information:
 * //
 * // error-type (\@see ~NetConf_RPCReplyElement_Error_Type):  
 * // 	  Defines the conceptual layer that the error occurred. 
 * //
 * // error-tag:  Contains a string identifying the error condition.
 * //
 * // error-severity (\@see ~NetConf_RPCReplyElement_Error_Severity):  
 * // 	  Contains an enum identifying the error severity, as
 * //    determined by the device.
 * //
 * // error-app-tag:  Contains a string identifying the data-model-specific
 * //    or implementation-specific error condition, if one exists.  This
 * //    element will not be present if no appropriate application error-
 * //    tag can be associated with a particular error condition.  If a
 * //	  data-model-specific and an implementation-specific error-app-tag
 * //    both exist, then the data-model-specific value MUST be used by the
 * //    server.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConf_RPCReplyElement_Error extends NetConf_RPCReplyElement
 * {
 *     int error_type \@enum(NetConf_RPCReplyElement_Error_Type);
 *     string error_tag;//dont forget to add filter size to length
 *     int error_severity \@enum(NetConf_RPCReplyElement_Error_Severity);
 *     string error_app_tag;//dont forget to add filter size to length
 *     byteLength = 131;//<rpc-error><error-type>1</error-type><error-tag></error-tag><error-severity>1</error-severity><error-info></error-info></rpc-error>
 * }
 * </pre>
 */
class NetConf_RPCReplyElement_Error : public ::SDN4CoRE::NetConf_RPCReplyElement
{
  protected:
    int error_type;
    ::omnetpp::opp_string error_tag;
    int error_severity;
    ::omnetpp::opp_string error_app_tag;

  private:
    void copy(const NetConf_RPCReplyElement_Error& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConf_RPCReplyElement_Error&);

  public:
    NetConf_RPCReplyElement_Error(const char *name=nullptr, short kind=0);
    NetConf_RPCReplyElement_Error(const NetConf_RPCReplyElement_Error& other);
    virtual ~NetConf_RPCReplyElement_Error();
    NetConf_RPCReplyElement_Error& operator=(const NetConf_RPCReplyElement_Error& other);
    virtual NetConf_RPCReplyElement_Error *dup() const override {return new NetConf_RPCReplyElement_Error(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getError_type() const;
    virtual void setError_type(int error_type);
    virtual const char * getError_tag() const;
    virtual void setError_tag(const char * error_tag);
    virtual int getError_severity() const;
    virtual void setError_severity(int error_severity);
    virtual const char * getError_app_tag() const;
    virtual void setError_app_tag(const char * error_app_tag);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConf_RPCReplyElement_Error& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConf_RPCReplyElement_Error& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfMessage.msg:171</tt> by nedtool.
 * <pre>
 * //
 * // The <ok> element is sent in <rpc-reply> messages if no errors or
 * // warnings occurred during the processing of an <rpc> request, and no
 * // data was returned from the operation. 
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConf_RPCReplyElement_Ok extends NetConf_RPCReplyElement
 * {
 *     byteLength = 5;//<ok/>
 * }
 * </pre>
 */
class NetConf_RPCReplyElement_Ok : public ::SDN4CoRE::NetConf_RPCReplyElement
{
  protected:

  private:
    void copy(const NetConf_RPCReplyElement_Ok& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConf_RPCReplyElement_Ok&);

  public:
    NetConf_RPCReplyElement_Ok(const char *name=nullptr, short kind=0);
    NetConf_RPCReplyElement_Ok(const NetConf_RPCReplyElement_Ok& other);
    virtual ~NetConf_RPCReplyElement_Ok();
    NetConf_RPCReplyElement_Ok& operator=(const NetConf_RPCReplyElement_Ok& other);
    virtual NetConf_RPCReplyElement_Ok *dup() const override {return new NetConf_RPCReplyElement_Ok(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConf_RPCReplyElement_Ok& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConf_RPCReplyElement_Ok& obj) {obj.parsimUnpack(b);}

} // namespace SDN4CoRE

#endif // ifndef __SDN4CORE_NETCONFMESSAGE_M_H

