//
// Generated file, do not edit! Created by nedtool 5.5 from sdn4core/netconf/messages/NetConfOperation.msg.
//

#ifndef __SDN4CORE_NETCONFOPERATION_M_H
#define __SDN4CORE_NETCONFOPERATION_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0505
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "sdn4core/netconf/datastructures/base/NetConfFilter.h"
// }}


namespace SDN4CoRE {

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:59</tt> by nedtool.
 * <pre>
 * //
 * // Base class for all NetConf operations.
 * //
 * // Protocol Operations
 * //   The NETCONF protocol provides a small set of low-level operations to
 * //   manage device configurations and retrieve device state information.
 * //   The base protocol provides operations to retrieve, configure, copy,
 * //   and delete configuration datastores.  Additional operations are
 * //   provided, based on the capabilities advertised by the device.
 * //
 * //   The base protocol includes the following protocol operations:
 * //   o  get
 * //   o  get-config
 * //   o  edit-config
 * //   o  copy-config
 * //   o  delete-config
 * //   o  lock
 * //   o  unlock
 * //   o  close-session
 * //   o  kill-session
 * //
 * //   A protocol operation can fail for various reasons, including
 * //   "operation not supported".  An initiator SHOULD NOT assume that any
 * //   operation will always succeed.  The return values in any RPC reply
 * //   SHOULD be checked for error responses.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation
 * {
 * }
 * </pre>
 */
class NetConfOperation : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const NetConfOperation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation&);

  public:
    NetConfOperation(const char *name=nullptr, short kind=0);
    NetConfOperation(const NetConfOperation& other);
    virtual ~NetConfOperation();
    NetConfOperation& operator=(const NetConfOperation& other);
    virtual NetConfOperation *dup() const override {return new NetConfOperation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:80</tt> by nedtool.
 * <pre>
 * // <get-config>
 * //
 * // Retrieve all or part of a specified configuration datastore.
 * //   Parameters:
 * //      source:  Name of the configuration datastore being queried, such
 * //         as <running/>.
 * //      filter:  This parameter identifies the portions of the device
 * //         configuration datastore to retrieve.  If this parameter is not
 * //         present, the entire configuration is returned.
 * //   Positive Response:  If the device can satisfy the request, the server
 * //      sends an <rpc-reply> element containing a <data> element with the
 * //      results of the query.
 * //   Negative Response:  An <rpc-error> element is included in the
 * //      <rpc-reply> if the request cannot be completed for any reason.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation_GetConfig extends NetConfOperation
 * {
 *     string source;//dont forget to add string size to length
 *     NetConfFilter filter;//dont forget to add filter size to length
 *     byteLength = 133;//<get-config><source></></source><filter type="subtree"><top xmlns="http://example.com/schema/1.2/config"></top></filter></get-config>  
 * }
 * </pre>
 */
class NetConfOperation_GetConfig : public ::SDN4CoRE::NetConfOperation
{
  protected:
    ::omnetpp::opp_string source;
    NetConfFilter filter;

  private:
    void copy(const NetConfOperation_GetConfig& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_GetConfig&);

  public:
    NetConfOperation_GetConfig(const char *name=nullptr, short kind=0);
    NetConfOperation_GetConfig(const NetConfOperation_GetConfig& other);
    virtual ~NetConfOperation_GetConfig();
    NetConfOperation_GetConfig& operator=(const NetConfOperation_GetConfig& other);
    virtual NetConfOperation_GetConfig *dup() const override {return new NetConfOperation_GetConfig(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getSource() const;
    virtual void setSource(const char * source);
    virtual NetConfFilter& getFilter();
    virtual const NetConfFilter& getFilter() const {return const_cast<NetConfOperation_GetConfig*>(this)->getFilter();}
    virtual void setFilter(const NetConfFilter& filter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_GetConfig& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_GetConfig& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:147</tt> by nedtool.
 * <pre>
 * //
 * // Attributes:
 * //    
 * //     operation:  Elements in the <config> subtree MAY contain an
 * //       "operation" attribute.  The attribute identifies the point in
 * //       the configuration to perform the operation and MAY appear on
 * //       multiple elements throughout the <config> subtree.
 * //
 * //       If the "operation" attribute is not specified, the
 * //       configuration is merged into the configuration datastore.
 * //       The "operation" attribute has one of the following values:
 * //
 * //       merge:  The configuration data identified by the element
 * //          containing this attribute is merged with the configuration
 * //          at the corresponding level in the configuration datastore
 * //          identified by the <target> parameter.  This is the default
 * //          behavior.
 * //
 * //       replace:  The configuration data identified by the element
 * //          containing this attribute replaces any related configuration
 * //          in the configuration datastore identified by the <target>
 * //          parameter.  If no such configuration data exists in the
 * //          configuration datastore, it is created.  Unlike a
 * //          <copy-config> operation, which replaces the entire target
 * //          configuration, only the configuration actually present in
 * //          the <config> parameter is affected.
 * //
 * //       create:  The configuration data identified by the element
 * //          containing this attribute is added to the configuration if
 * //          and only if the configuration data does not already exist in
 * //          the configuration datastore.  If the configuration data
 * //          exists, an <rpc-error> element is returned with an
 * //          <error-tag> value of "data-exists".
 * //
 * //       delete:  The configuration data identified by the element
 * //          containing this attribute is deleted from the configuration
 * //          if and only if the configuration data currently exists in
 * //          the configuration datastore.  If the configuration data does
 * //          not exist, an <rpc-error> element is returned with an
 * //          <error-tag> value of "data-missing".
 * //
 * //       remove:  The configuration data identified by the element
 * //          containing this attribute is deleted from the configuration
 * //          if the configuration data currently exists in the
 * //          configuration datastore.  If the configuration data does not
 * //          exist, the "remove" operation is silently ignored by the
 * //          server.
 * //
 * //       none:  The target datastore is unaffected by the configuration
 * //          in the <config> parameter, unless and until the incoming
 * //          configuration data uses the "operation" attribute to request
 * //          a different operation.  If the configuration in the <config>
 * //          parameter contains data for which there is not a
 * //          corresponding level in the target datastore, an <rpc-error>
 * //          is returned with an <error-tag> value of data-missing.
 * //          Using "none" allows operations like "delete" to avoid
 * //          unintentionally creating the parent hierarchy of the element
 * //          to be deleted.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * enum NetConfOperation_Operation
 * {
 *     NETCONFOPERATION_OPERATION_NONE = 0;
 *     NETCONFOPERATION_OPERATION_MERGE = 1;
 *     NETCONFOPERATION_OPERATION_REPLACE = 2;
 *     NETCONFOPERATION_OPERATION_CREATE = 3;
 *     NETCONFOPERATION_OPERATION_DELETE = 4;
 *     NETCONFOPERATION_OPERATION_REMOVE = 5;
 * }
 * </pre>
 */
enum NetConfOperation_Operation {
    NETCONFOPERATION_OPERATION_NONE = 0,
    NETCONFOPERATION_OPERATION_MERGE = 1,
    NETCONFOPERATION_OPERATION_REPLACE = 2,
    NETCONFOPERATION_OPERATION_CREATE = 3,
    NETCONFOPERATION_OPERATION_DELETE = 4,
    NETCONFOPERATION_OPERATION_REMOVE = 5
};

/**
 * Enum generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:176</tt> by nedtool.
 * <pre>
 * //
 * //  error-option:  The <error-option> element has one of the following
 * //         values:
 * //
 * //         stop-on-error:  Abort the <edit-config> operation on first
 * //            error.  This is the default error-option.
 * //
 * //         continue-on-error:  Continue to process configuration data on
 * //            error; error is recorded, and negative response is generated
 * //            if any errors occur.
 * //
 * //         rollback-on-error:  If an error condition occurs such that an
 * //            error severity <rpc-error> element is generated, the server
 * //            will stop processing the <edit-config> operation and restore
 * //            the specified configuration to its complete state at the
 * //            start of this <edit-config> operation.  This option requires
 * //            the server to support the :rollback-on-error capability.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * enum NetConfOperation_ErrorOption
 * {
 *     NETCONFOPERATION_ERROROPTION_STOPONERROR = 0;
 *     NETCONFOPERATION_ERROROPTION_CONTINUEONERROR = 1;
 *     NETCONFOPERATION_ERROROPTION_ROLLBACKONERROR = 2;
 * }
 * </pre>
 */
enum NetConfOperation_ErrorOption {
    NETCONFOPERATION_ERROROPTION_STOPONERROR = 0,
    NETCONFOPERATION_ERROROPTION_CONTINUEONERROR = 1,
    NETCONFOPERATION_ERROROPTION_ROLLBACKONERROR = 2
};

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:242</tt> by nedtool.
 * <pre>
 * //
 * // <edit-config>
 * //
 * // The <edit-config> operation loads all or part of a specified
 * // configuration to the specified target configuration datastore.
 * // This operation allows the new configuration to be expressed in
 * // several ways, such as using a local file, a remote file, or
 * // inline.  If the target configuration datastore does not exist, it
 * // will be created.
 * //
 * // The device analyzes the source and target configurations and
 * // performs the requested changes.  The target configuration is not
 * // necessarily replaced, as with the <copy-config> message.  Instead,
 * // the target configuration is changed in accordance with the
 * // source's data and requested operations.
 * //
 * // If the <edit-config> operation contains multiple sub-operations
 * // that apply to the same conceptual node in the underlying data
 * // model, then the result of the operation is undefined (i.e.,
 * // outside the scope of the NETCONF protocol).
 * //
 * // Attributes:
 * //    
 * //     operation (\@see ~NetConfOperation_Operation):  Elements in the <config> 
 * //       subtree MAY contain an "operation" attribute.  The attribute identifies
 * //       the point in the configuration to perform the operation and MAY 
 * //       appear on multiple elements throughout the <config> subtree.
 * //
 * //       If the "operation" attribute is not specified, the
 * //       configuration is merged into the configuration datastore.
 * //
 * // Parameters:
 * //    target:  Name of the configuration datastore being edited, such as
 * //       <running/> or <candidate/>.
 * //
 * //    default-operation:  Selects the default operation (\@see ~NetConfOperation_Operation)
 * //       for this <edit-config> request.  The
 * //       default value for the <default-operation> parameter is "merge".
 * //       The <default-operation> parameter is optional, but if provided,
 * //       it has one of the following values: merge, replace, none
 * //
 * //    error-option:  The <error-option> element has one of the following
 * //       values (\@see~NetConfOperation_ErrorOption).
 * //
 * //    config:  encapsulated packet \@see ~NetConfConfig 
 * //		 A hierarchy of configuration data as defined by one of
 * //       the device's data models.  The contents MUST be placed in an
 * //       appropriate namespace, to allow the device to detect the
 * //       appropriate data model, and the contents MUST follow the
 * //       constraints of that data model, as defined by its capability
 * //       definition.  Capabilities are discussed in Section 8.
 * //
 * //   Positive Response:  If the device was able to satisfy the request, an
 * //      <rpc-reply> is sent containing an <ok> element.
 * //
 * //   Negative Response:  An <rpc-error> response is sent if the request
 * //      cannot be completed for any reason.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation_EditConfig extends NetConfOperation
 * {
 *     string target;//dont forget to add string size to length
 *     int defaultOperation \@enum(NetConfOperation_Operation);
 *     int errorOption \@enum(NetConfOperation_ErrorOption);
 *     byteLength = 119;//<edit-config><target></></target><defaultOperation>1</defaultOperation><errorOperation>1</errorOperation></edit-config>
 * }
 * </pre>
 */
class NetConfOperation_EditConfig : public ::SDN4CoRE::NetConfOperation
{
  protected:
    ::omnetpp::opp_string target;
    int defaultOperation;
    int errorOption;

  private:
    void copy(const NetConfOperation_EditConfig& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_EditConfig&);

  public:
    NetConfOperation_EditConfig(const char *name=nullptr, short kind=0);
    NetConfOperation_EditConfig(const NetConfOperation_EditConfig& other);
    virtual ~NetConfOperation_EditConfig();
    NetConfOperation_EditConfig& operator=(const NetConfOperation_EditConfig& other);
    virtual NetConfOperation_EditConfig *dup() const override {return new NetConfOperation_EditConfig(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getTarget() const;
    virtual void setTarget(const char * target);
    virtual int getDefaultOperation() const;
    virtual void setDefaultOperation(int defaultOperation);
    virtual int getErrorOption() const;
    virtual void setErrorOption(int errorOption);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_EditConfig& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_EditConfig& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:262</tt> by nedtool.
 * <pre>
 * //
 * // Configuration element used in both edit_config and get_config 
 * // has to be extended by specific configurators.
 * //
 * //    operation:  Selects the operation (\@see ~NetConfOperation_Operation)
 * //       for this configuration in an edit_config request.  
 * //	     If this is not set the default value from the <default-operation> 
 * //		 parameter in \@see ~NetConfOperation_EditConfig.
 * //       The <operation> parameter is optional, but if provided,
 * //       it has one of the values in \@see ~NetConfOperation_Operation.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfConfig
 * {
 *     \@customize(true);
 *     int operation \@enum(NetConfOperation_Operation);
 * }
 * </pre>
 *
 * NetConfConfig_Base is only useful if it gets subclassed, and NetConfConfig is derived from it.
 * The minimum code to be written for NetConfConfig is the following:
 *
 * <pre>
 * class NetConfConfig : public NetConfConfig_Base
 * {
 *   private:
 *     void copy(const NetConfConfig& other) { ... }

 *   public:
 *     NetConfConfig(const char *name=nullptr, short kind=0) : NetConfConfig_Base(name,kind) {}
 *     NetConfConfig(const NetConfConfig& other) : NetConfConfig_Base(other) {copy(other);}
 *     NetConfConfig& operator=(const NetConfConfig& other) {if (this==&other) return *this; NetConfConfig_Base::operator=(other); copy(other); return *this;}
 *     virtual NetConfConfig *dup() const override {return new NetConfConfig(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from NetConfConfig_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(NetConfConfig)
 * </pre>
 */
class NetConfConfig_Base : public ::omnetpp::cPacket
{
  protected:
    int operation;

  private:
    void copy(const NetConfConfig_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfConfig_Base&);
    // make constructors protected to avoid instantiation
    NetConfConfig_Base(const char *name=nullptr, short kind=0);
    NetConfConfig_Base(const NetConfConfig_Base& other);
    // make assignment operator protected to force the user override it
    NetConfConfig_Base& operator=(const NetConfConfig_Base& other);

  public:
    virtual ~NetConfConfig_Base();
    virtual NetConfConfig_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class NetConfConfig");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getOperation() const;
    virtual void setOperation(int operation);
};

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:292</tt> by nedtool.
 * <pre>
 * //
 * // <copy-config>
 * //
 * // Create or replace an entire configuration datastore
 * // with the contents of another complete configuration datastore.  If
 * // the target datastore exists, it is overwritten.  Otherwise, a new
 * // one is created, if allowed.
 * //
 * // Parameters:
 * //
 * //    target:  Name of the configuration datastore to use as the
 * //       destination of the <copy-config> operation.
 * //
 * //    source:  Name of the configuration datastore to use as the source
 * //         of the <copy-config> operation, or the <config> element
 * //         containing the complete configuration to copy.
 * //
 * // Positive Response:  If the device was able to satisfy the request, an
 * //    <rpc-reply> is sent that includes an <ok> element.
 * //
 * // Negative Response:  An <rpc-error> element is included within the
 * //    <rpc-reply> if the request cannot be completed for any reason.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation_CopyConfig extends NetConfOperation
 * {
 *     string source;//dont forget to add string size to length
 *     string target;//dont forget to add string size to length
 *     byteLength = 67;//<copy-config><target></></target><source></></source></copy-config>
 * }
 * </pre>
 */
class NetConfOperation_CopyConfig : public ::SDN4CoRE::NetConfOperation
{
  protected:
    ::omnetpp::opp_string source;
    ::omnetpp::opp_string target;

  private:
    void copy(const NetConfOperation_CopyConfig& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_CopyConfig&);

  public:
    NetConfOperation_CopyConfig(const char *name=nullptr, short kind=0);
    NetConfOperation_CopyConfig(const NetConfOperation_CopyConfig& other);
    virtual ~NetConfOperation_CopyConfig();
    NetConfOperation_CopyConfig& operator=(const NetConfOperation_CopyConfig& other);
    virtual NetConfOperation_CopyConfig *dup() const override {return new NetConfOperation_CopyConfig(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getSource() const;
    virtual void setSource(const char * source);
    virtual const char * getTarget() const;
    virtual void setTarget(const char * target);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_CopyConfig& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_CopyConfig& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:316</tt> by nedtool.
 * <pre>
 * //
 * // <delete-config>
 * //
 * // Delete a configuration datastore.  The <running>
 * // configuration datastore cannot be deleted.
 * //
 * //   Parameters:
 * //
 * //      target:  Name of the configuration datastore to delete.
 * //
 * //   Positive Response:  If the device was able to satisfy the request, an
 * //      <rpc-reply> is sent that includes an <ok> element.
 * //
 * //   Negative Response:  An <rpc-error> element is included within the
 * //      <rpc-reply> if the request cannot be completed for any reason.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation_DeleteConfig extends NetConfOperation
 * {
 *     string target;//dont forget to add string size to length
 *     byteLength = 51;//<delete-config><target></></target></delete-config>
 * }
 * </pre>
 */
class NetConfOperation_DeleteConfig : public ::SDN4CoRE::NetConfOperation
{
  protected:
    ::omnetpp::opp_string target;

  private:
    void copy(const NetConfOperation_DeleteConfig& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_DeleteConfig&);

  public:
    NetConfOperation_DeleteConfig(const char *name=nullptr, short kind=0);
    NetConfOperation_DeleteConfig(const NetConfOperation_DeleteConfig& other);
    virtual ~NetConfOperation_DeleteConfig();
    NetConfOperation_DeleteConfig& operator=(const NetConfOperation_DeleteConfig& other);
    virtual NetConfOperation_DeleteConfig *dup() const override {return new NetConfOperation_DeleteConfig(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getTarget() const;
    virtual void setTarget(const char * target);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_DeleteConfig& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_DeleteConfig& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:342</tt> by nedtool.
 * <pre>
 * //
 * // <get>
 * //
 * // Retrieve running configuration and device state information.
 * //
 * //   Parameters:
 * //
 * //      filter:  This parameter specifies the portion of the system
 * //         configuration and state data to retrieve.  If this parameter is
 * //         not present, all the device configuration and state information
 * //         is returned.
 * //
 * //   Positive Response:  If the device was able to satisfy the request, an
 * //      <rpc-reply> is sent.  The <data> section contains the appropriate
 * //      subset.
 * //
 * //   Negative Response:  An <rpc-error> element is included in the
 * //      <rpc-reply> if the request cannot be completed for any reason.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation_Get extends NetConfOperation
 * {
 *     NetConfFilter filter;//dont forget to add filter size to length
 *     byteLength = 99;//<get><filter type="subtree"><top xmlns="http://example.com/schema/1.2/config"></top></filter></get>    
 * }
 * </pre>
 */
class NetConfOperation_Get : public ::SDN4CoRE::NetConfOperation
{
  protected:
    NetConfFilter filter;

  private:
    void copy(const NetConfOperation_Get& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_Get&);

  public:
    NetConfOperation_Get(const char *name=nullptr, short kind=0);
    NetConfOperation_Get(const NetConfOperation_Get& other);
    virtual ~NetConfOperation_Get();
    NetConfOperation_Get& operator=(const NetConfOperation_Get& other);
    virtual NetConfOperation_Get *dup() const override {return new NetConfOperation_Get(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual NetConfFilter& getFilter();
    virtual const NetConfFilter& getFilter() const {return const_cast<NetConfOperation_Get*>(this)->getFilter();}
    virtual void setFilter(const NetConfFilter& filter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_Get& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_Get& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:366</tt> by nedtool.
 * <pre>
 * //
 * // <close-session>
 * //
 * // Request graceful termination of a NETCONF session.
 * //
 * // When a NETCONF server receives a <close-session> request, it will
 * // gracefully close the session.  The server will release any locks
 * // and resources associated with the session and gracefully close any
 * // associated connections.  Any NETCONF requests received after a
 * // <close-session> request will be ignored.
 * //
 * //   Positive Response:  If the device was able to satisfy the request, an
 * //      <rpc-reply> is sent that includes an <ok> element.
 * //
 * //   Negative Response:  An <rpc-error> element is included in the
 * //      <rpc-reply> if the request cannot be completed for any reason.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * packet NetConfOperation_CloseSession extends NetConfOperation
 * {
 *     byteLength = 16;//<close-session/>
 * }
 * </pre>
 */
class NetConfOperation_CloseSession : public ::SDN4CoRE::NetConfOperation
{
  protected:

  private:
    void copy(const NetConfOperation_CloseSession& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_CloseSession&);

  public:
    NetConfOperation_CloseSession(const char *name=nullptr, short kind=0);
    NetConfOperation_CloseSession(const NetConfOperation_CloseSession& other);
    virtual ~NetConfOperation_CloseSession();
    NetConfOperation_CloseSession& operator=(const NetConfOperation_CloseSession& other);
    virtual NetConfOperation_CloseSession *dup() const override {return new NetConfOperation_CloseSession(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_CloseSession& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_CloseSession& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:446</tt> by nedtool.
 * <pre>
 * //
 * // <lock>
 * //
 * //	The <lock> operation allows the client to lock the
 * //	entire configuration datastore system of a device.  Such locks are
 * //	intended to be short-lived and allow a client to make a change
 * //	without fear of interaction with other NETCONF clients, non-
 * //	NETCONF clients (e.g., SNMP and command line interface (CLI)
 * //	scripts), and human users.
 * //
 * //	An attempt to lock the configuration datastore MUST fail if an
 * //	existing session or other entity holds a lock on any portion of
 * //	the lock target.
 * //
 * //	When the lock is acquired, the server MUST prevent any changes to
 * //	the locked resource other than those requested by this session.
 * //	SNMP and CLI requests to modify the resource MUST fail with an
 * //	appropriate error.
 * //
 * //	The duration of the lock is defined as beginning when the lock is
 * //	acquired and lasting until either the lock is released or the
 * //	NETCONF session closes.  The session closure can be explicitly
 * //	performed by the client, or implicitly performed by the server
 * //	based on criteria such as failure of the underlying transport,
 * //	simple inactivity timeout, or detection of abusive behavior on the
 * //	part of the client.  These criteria are dependent on the
 * //	implementation and the underlying transport.
 * //
 * //	The <lock> operation takes a mandatory parameter, <target>.  The
 * //	<target> parameter names the configuration datastore that will be
 * //	locked.  When a lock is active, using the <edit-config> operation
 * //	on the locked configuration datastore and using the locked
 * //	configuration as a target of the <copy-config> operation will be
 * //	disallowed by any other NETCONF session.  Additionally, the system
 * //	will ensure that these locked configuration resources will not be
 * //	modified by other non-NETCONF management operations such as SNMP
 * //	and CLI.  The <kill-session> operation can be used to force the
 * //	release of a lock owned by another NETCONF session.  It is beyond
 * //	the scope of this document to define how to break locks held by
 * //	other entities.
 * //
 * //	A lock MUST NOT be granted if any of the following conditions is
 * //	true:
 * //
 * //	*	A lock is already held by any NETCONF session or another
 * //		entity.
 * //	*	The target configuration is <candidate>, it has already been
 * //		modified, and these changes have not been committed or rolled
 * //		back.
 * //	*	The target configuration is <running>, and another NETCONF
 * //		session has an ongoing confirmed commit (Section 8.4).
 * //	
 * //		The server MUST respond with either an <ok> element or an
 * //		<rpc-error>.
 * //
 * //		A lock will be released by the system if the session holding the
 * //		lock is terminated for any reason.
 * //
 * //	Parameters:
 * //	target:  Name of the configuration datastore to lock.
 * //
 * //	Positive Response:  If the device was able to satisfy the request, an
 * //	<rpc-reply> is sent that contains an <ok> element.
 * //
 * //	Negative Response:  An <rpc-error> element is included in the
 * //	<rpc-reply> if the request cannot be completed for any reason.
 * //
 * //	If the lock is already held, the <error-tag> element will be
 * //	"lock-denied" and the <error-info> element will include the
 * //	<session-id> of the lock owner.  If the lock is held by a non-
 * //	NETCONF entity, a <session-id> of 0 (zero) is included.  Note that
 * //	any other entity performing a lock on even a partial piece of a
 * //	target will prevent a NETCONF lock (which is global) from being
 * //	obtained on that target.
 * //
 * //
 * packet NetConfOperation_Lock extends NetConfOperation
 * {
 *     string target;//dont forget to add string size to length
 *     byteLength = 33;//<lock><target></></target></lock>
 * }
 * </pre>
 */
class NetConfOperation_Lock : public ::SDN4CoRE::NetConfOperation
{
  protected:
    ::omnetpp::opp_string target;

  private:
    void copy(const NetConfOperation_Lock& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_Lock&);

  public:
    NetConfOperation_Lock(const char *name=nullptr, short kind=0);
    NetConfOperation_Lock(const NetConfOperation_Lock& other);
    virtual ~NetConfOperation_Lock();
    NetConfOperation_Lock& operator=(const NetConfOperation_Lock& other);
    virtual NetConfOperation_Lock *dup() const override {return new NetConfOperation_Lock(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getTarget() const;
    virtual void setTarget(const char * target);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_Lock& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_Lock& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:481</tt> by nedtool.
 * <pre>
 * //
 * // <unlock>
 * //
 * //	The <unlock> operation is used to release a
 * //	configuration lock, previously obtained with the <lock> operation.
 * //
 * //	An <unlock> operation will not succeed if either of the following
 * //	conditions is true:
 * //    
 * //    * The specified lock is not currently active.
 * //    * The session issuing the <unlock> operation is not the same
 * //    session that obtained the lock.
 * //    
 * //    The server MUST respond with either an <ok> element or an
 * //    <rpc-error>.
 * //    
 * //    Parameters:
 * //    
 * //    target:  Name of the configuration datastore to unlock.
 * //    
 * //    A NETCONF client is not permitted to unlock a configuration
 * //    datastore that it did not lock.
 * //    	
 * //    Positive Response:  If the device was able to satisfy the request, an
 * //    <rpc-reply> is sent that contains an <ok> element.
 * //    
 * //    Negative Response:  An <rpc-error> element is included in the
 * //    <rpc-reply> if the request cannot be completed for any reason.
 * //
 * //
 * packet NetConfOperation_Unlock extends NetConfOperation
 * {
 *     string target;//dont forget to add string size to length
 *     byteLength = 37;//<unlock><target></></target></unlock>
 * }
 * </pre>
 */
class NetConfOperation_Unlock : public ::SDN4CoRE::NetConfOperation
{
  protected:
    ::omnetpp::opp_string target;

  private:
    void copy(const NetConfOperation_Unlock& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_Unlock&);

  public:
    NetConfOperation_Unlock(const char *name=nullptr, short kind=0);
    NetConfOperation_Unlock(const NetConfOperation_Unlock& other);
    virtual ~NetConfOperation_Unlock();
    NetConfOperation_Unlock& operator=(const NetConfOperation_Unlock& other);
    virtual NetConfOperation_Unlock *dup() const override {return new NetConfOperation_Unlock(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getTarget() const;
    virtual void setTarget(const char * target);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_Unlock& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_Unlock& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:519</tt> by nedtool.
 * <pre>
 * //	<commit>
 * //    When the candidate configuration's content is complete, the
 * //    configuration data can be committed, publishing the data set to
 * //    the rest of the device and requesting the device to conform to
 * //    the behavior described in the new configuration.
 * //    
 * //    To commit the candidate configuration as the device's new
 * //    current configuration, use the <commit> operation.
 * //    
 * //    The <commit> operation instructs the device to implement the
 * //    configuration data contained in the candidate configuration.
 * //    If the device is unable to commit all of the changes in the
 * //    candidate configuration datastore, then the running
 * //    configuration MUST remain unchanged.  If the device does
 * //    succeed in committing, the running configuration MUST be
 * //    updated with the contents of the candidate configuration.
 * //    
 * //    If the running or candidate configuration is currently locked
 * //    by a different session, the <commit> operation MUST fail with
 * //    an <error-tag> value of "in-use".
 * //    
 * //    If the system does not have the :candidate capability, the
 * //    <commit> operation is not available.
 * //    
 * //    Positive Response:
 * //    If the device was able to satisfy the request, an <rpc-reply>
 * //    is sent that contains an <ok> element.
 * //    
 * //    Negative Response:
 * //    An <rpc-error> element is included in the <rpc-reply> if the
 * //    request cannot be completed for any reason.
 * //
 * //
 * packet NetConfOperation_Commit extends NetConfOperation
 * {
 *     byteLength = 9;//<commit/>
 * }
 * </pre>
 */
class NetConfOperation_Commit : public ::SDN4CoRE::NetConfOperation
{
  protected:

  private:
    void copy(const NetConfOperation_Commit& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_Commit&);

  public:
    NetConfOperation_Commit(const char *name=nullptr, short kind=0);
    NetConfOperation_Commit(const NetConfOperation_Commit& other);
    virtual ~NetConfOperation_Commit();
    NetConfOperation_Commit& operator=(const NetConfOperation_Commit& other);
    virtual NetConfOperation_Commit *dup() const override {return new NetConfOperation_Commit(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_Commit& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_Commit& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfOperation.msg:533</tt> by nedtool.
 * <pre>
 * //
 * //	<discard-changes>
 * // If the client decides that the candidate configuration is not to be
 * // committed, the <discard-changes> operation can be used to revert the
 * // candidate configuration to the current running configuration.
 * //
 * // This operation discards any uncommitted changes by resetting the
 * // candidate configuration with the content of the running configuration.
 * //
 * //
 * packet NetConfOperation_Discard_Changes extends NetConfOperation
 * {
 *     byteLength = 18;//<discard-changes/>
 * }
 * </pre>
 */
class NetConfOperation_Discard_Changes : public ::SDN4CoRE::NetConfOperation
{
  protected:

  private:
    void copy(const NetConfOperation_Discard_Changes& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfOperation_Discard_Changes&);

  public:
    NetConfOperation_Discard_Changes(const char *name=nullptr, short kind=0);
    NetConfOperation_Discard_Changes(const NetConfOperation_Discard_Changes& other);
    virtual ~NetConfOperation_Discard_Changes();
    NetConfOperation_Discard_Changes& operator=(const NetConfOperation_Discard_Changes& other);
    virtual NetConfOperation_Discard_Changes *dup() const override {return new NetConfOperation_Discard_Changes(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfOperation_Discard_Changes& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfOperation_Discard_Changes& obj) {obj.parsimUnpack(b);}

} // namespace SDN4CoRE

#endif // ifndef __SDN4CORE_NETCONFOPERATION_M_H

