//
// Generated file, do not edit! Created by nedtool 5.5 from sdn4core/netconf/messages/NetConfCtrlInfo.msg.
//

#ifndef __SDN4CORE_NETCONFCTRLINFO_M_H
#define __SDN4CORE_NETCONFCTRLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0505
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "NetConfMessage_m.h"
// }}


namespace SDN4CoRE {

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfCtrlInfo.msg:33</tt> by nedtool.
 * <pre>
 * //
 * // Control info which is attached to a request by the NetConfServer, 
 * // when forwarded to a data store, or the other way around. 
 * // It is used to map a response to the request.
 * //
 * // \@author Timo Haeckel, for HAW Hamburg
 * //
 * class NetConfCtrlInfo
 * {
 *     int messageType \@enum(NetConfMessageType);
 *     string message_id;
 *     int session_id;
 * }
 * </pre>
 */
class NetConfCtrlInfo : public ::omnetpp::cObject
{
  protected:
    int messageType;
    ::omnetpp::opp_string message_id;
    int session_id;

  private:
    void copy(const NetConfCtrlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfCtrlInfo&);

  public:
    NetConfCtrlInfo();
    NetConfCtrlInfo(const NetConfCtrlInfo& other);
    virtual ~NetConfCtrlInfo();
    NetConfCtrlInfo& operator=(const NetConfCtrlInfo& other);
    virtual NetConfCtrlInfo *dup() const override {return new NetConfCtrlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getMessageType() const;
    virtual void setMessageType(int messageType);
    virtual const char * getMessage_id() const;
    virtual void setMessage_id(const char * message_id);
    virtual int getSession_id() const;
    virtual void setSession_id(int session_id);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfCtrlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfCtrlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sdn4core/netconf/messages/NetConfCtrlInfo.msg:39</tt> by nedtool.
 * <pre>
 * class NetConfClientCtrlInfo_Connection
 * {
 *     int localPort;
 *     string connectAddress;
 *     int connectPort;
 * }
 * </pre>
 */
class NetConfClientCtrlInfo_Connection : public ::omnetpp::cObject
{
  protected:
    int localPort;
    ::omnetpp::opp_string connectAddress;
    int connectPort;

  private:
    void copy(const NetConfClientCtrlInfo_Connection& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NetConfClientCtrlInfo_Connection&);

  public:
    NetConfClientCtrlInfo_Connection();
    NetConfClientCtrlInfo_Connection(const NetConfClientCtrlInfo_Connection& other);
    virtual ~NetConfClientCtrlInfo_Connection();
    NetConfClientCtrlInfo_Connection& operator=(const NetConfClientCtrlInfo_Connection& other);
    virtual NetConfClientCtrlInfo_Connection *dup() const override {return new NetConfClientCtrlInfo_Connection(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual const char * getConnectAddress() const;
    virtual void setConnectAddress(const char * connectAddress);
    virtual int getConnectPort() const;
    virtual void setConnectPort(int connectPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NetConfClientCtrlInfo_Connection& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NetConfClientCtrlInfo_Connection& obj) {obj.parsimUnpack(b);}

} // namespace SDN4CoRE

#endif // ifndef __SDN4CORE_NETCONFCTRLINFO_M_H

